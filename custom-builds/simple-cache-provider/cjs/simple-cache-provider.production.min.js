/** @license React v16.4.3-alpha.0
 * simple-cache-provider.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });

var React = require("react");

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

function noop() {}

var Empty = 0;
var Pending = 1;
var Resolved = 2;
var Rejected = 3;

// TODO: Make this configurable per resource
var MAX_SIZE = 500;
var PAGE_SIZE = 50;

function createRecord(key) {
  return {
    status: Empty,
    suspender: null,
    key: key,
    value: null,
    error: null,
    next: null,
    previous: null,
  };
}

function createRecordCache() {
  return {
    map: new Map(),
    head: null,
    tail: null,
    size: 0,
  };
}

function createCache(invalidator) {
  var resourceMap = new Map();

  function accessRecord(resourceType, key) {
    var recordCache = resourceMap.get(resourceType);
    if (recordCache === undefined) {
      recordCache = createRecordCache();
      resourceMap.set(resourceType, recordCache);
    }
    var map = recordCache.map;

    var record = map.get(key);
    if (record === undefined) {
      // This record does not already exist. Create a new one.
      record = createRecord(key);
      map.set(key, record);
      if (recordCache.size >= MAX_SIZE) {
        // The cache is already at maximum capacity. Remove PAGE_SIZE least
        // recently used records.
        // TODO: We assume the max capcity is greater than zero. Otherwise warn.
        var _tail = recordCache.tail;
        if (_tail !== null) {
          var newTail = _tail;
          for (var i = 0; i < PAGE_SIZE && newTail !== null; i++) {
            recordCache.size -= 1;
            map.delete(newTail.key);
            newTail = newTail.previous;
          }
          recordCache.tail = newTail;
          if (newTail !== null) {
            newTail.next = null;
          }
        }
      }
    } else {
      // This record is already cached. Remove it from its current position in
      // the list. We'll add it to the front below.
      var _previous = record.previous;
      var _next = record.next;
      if (_previous !== null) {
        _previous.next = _next;
      } else {
        recordCache.head = _next;
      }
      if (_next !== null) {
        _next.previous = _previous;
      } else {
        recordCache.tail = _previous;
      }
      recordCache.size -= 1;
    }

    // Add the record to the front of the list.
    var head = recordCache.head;
    var newHead = record;
    recordCache.head = newHead;
    newHead.previous = null;
    newHead.next = head;
    if (head !== null) {
      head.previous = newHead;
    } else {
      recordCache.tail = newHead;
    }
    recordCache.size += 1;

    return newHead;
  }

  function load(emptyRecord, suspender) {
    var pendingRecord = emptyRecord;
    pendingRecord.status = Pending;
    pendingRecord.suspender = suspender;
    suspender.then(
      function(value) {
        // Resource loaded successfully.
        var resolvedRecord = pendingRecord;
        resolvedRecord.status = Resolved;
        resolvedRecord.suspender = null;
        resolvedRecord.value = value;
      },
      function(error) {
        // Resource failed to load. Stash the error for later so we can throw it
        var rejectedRecord = pendingRecord;
        rejectedRecord.status = Rejected;
        rejectedRecord.suspender = null;
        rejectedRecord.error = error;
      },
    );
  }

  var cache = {
    invalidate: function() {
      invalidator();
    },
    preload: function(resourceType, key, miss, missArg) {
      var record = accessRecord(resourceType, key);
      switch (record.status) {
        case Empty:
          // Warm the cache.
          var _suspender = miss(missArg);
          load(record, _suspender);
          return;
        case Pending:
          // There's already a pending request.
          return;
        case Resolved:
          // The resource is already in the cache.
          return;
        case Rejected:
          // The request failed.
          return;
      }
    },
    read: function(resourceType, key, miss, missArg) {
      var record = accessRecord(resourceType, key);
      switch (record.status) {
        case Empty:
          // Load the requested resource.
          var _suspender2 = miss(missArg);
          load(record, _suspender2);
          throw _suspender2;
        case Pending:
          // There's already a pending request.
          throw record.suspender;
        case Resolved:
          return record.value;
        case Rejected:
        default:
          // The requested resource previously failed loading.
          var _error = record.error;
          throw _error;
      }
    },
  };

  return cache;
}

// These declarations are used to express function overloading. I wish there
// were a more elegant way to do this in the function definition itself.

// Primitive keys do not request a hash function.

// Non-primitive keys *do* require a hash function.
// eslint-disable-next-line no-redeclare

// eslint-disable-next-line no-redeclare
function createResource(loadResource, hash) {
  var resource = {
    read: function(cache, key) {
      if (hash === undefined) {
        return cache.read(resource, key, loadResource, key);
      }
      var hashedKey = hash(key);
      return cache.read(resource, hashedKey, loadResource, key);
    },
    preload: function(cache, key) {
      if (hash === undefined) {
        cache.preload(resource, key, loadResource, key);
        return;
      }
      var hashedKey = hash(key);
      cache.preload(resource, hashedKey, loadResource, key);
    },
  };
  return resource;
}

// Global cache has no eviction policy (except for, ya know, a browser refresh).
var globalCache = createCache(noop);
var SimpleCache = React.createContext(globalCache);

exports.createCache = createCache;
exports.createResource = createResource;
exports.SimpleCache = SimpleCache;
